# src/app/modules/ingestion/extractor.py
import json
import logging
from typing import Optional, Dict

from google import genai
from google.genai import types
import httpx
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
)

from app.config import settings

# Set up logging
logger = logging.getLogger(__name__)

# Configure the Gemini client
client = None
try:
    # Use the unified key from settings
    client = genai.Client(api_key=settings.gemini_api_key)
    print("Ingestion GenAI client configured successfully")
except Exception as e:
    print(f"Ingestion GenAI client configuration failed, check API key. Error: {e}")

# The EXTRACTION_PROMPT is now removed from this file.
# It will be dynamically generated by the ingestion service.


@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10),
    retry=retry_if_exception_type(
        (httpx.ConnectError, httpx.TimeoutException, ConnectionError)
    ),
)
def generate_content_with_retry_extraction(client, model, contents, config):
    """Generate content with retry logic for PDF extraction"""
    try:
        response_text = ""
        chunk_count = 0
        
        logger.debug(f"Starting streaming content generation with model: {model}")
        
        for chunk in client.models.generate_content_stream(
            model=model,
            contents=contents,
            config=config,
        ):
            chunk_count += 1
            if chunk.text:
                response_text += chunk.text
                logger.debug(f"Received chunk {chunk_count}, length: {len(chunk.text)}")
            else:
                logger.debug(f"Received empty chunk {chunk_count}")
        
        logger.info(f"Streaming completed. Total chunks: {chunk_count}, Total response length: {len(response_text)}")
        
        if not response_text.strip():
            logger.warning("Streaming completed but response is empty")
            
        return response_text
        
    except (httpx.ConnectError, httpx.TimeoutException, ConnectionError) as e:
        logger.warning(f"Streaming failed with {type(e).__name__}: {e}. Retrying...")
        raise  # This will trigger the retry mechanism
    except Exception as e:
        logger.error(f"Unexpected error during streaming: {type(e).__name__}: {e}")
        raise


def extract_data_from_pdf(pdf_content: bytes, extraction_prompt: str) -> Optional[Dict]:
    """
    Sends PDF content to Gemini and gets structured JSON data back.
    The prompt is now passed in as an argument.
    """
    if not client:
        logger.error("Extractor: GenAI client not available. Cannot process PDF.")
        logger.error("Please check if GEMINI_API_KEY is set in your environment variables.")
        logger.error("You can set it in your .env file: GEMINI_API_KEY=your_api_key_here")
        return None
    
    if not settings.gemini_api_key or settings.gemini_api_key.strip() == "":
        logger.error("Gemini API key is empty or not configured.")
        logger.error("Please set GEMINI_API_KEY in your .env file or environment variables.")
        return None

    try:
        # Create content for the request
        contents = [
            types.Content(
                role="user",
                parts=[
                    types.Part.from_text(
                        text=extraction_prompt
                    ),  # Use the passed-in prompt
                    types.Part.from_bytes(
                        data=pdf_content, mime_type="application/pdf"
                    ),
                ],
            )
        ]

        try:
            # Log the request details for debugging
            logger.info(f"Processing PDF with Gemini API")
            logger.info(f"PDF size: {len(pdf_content)} bytes")
            logger.info(f"Model: {settings.gemini_model_name}")
            logger.info(f"Prompt length: {len(extraction_prompt)} characters")

            # Configure for JSON output
            generate_content_config = types.GenerateContentConfig(
                thinking_config=types.ThinkingConfig(thinking_budget=0),
                safety_settings=[
                    types.SafetySetting(
                        category="HARM_CATEGORY_HARASSMENT", threshold="BLOCK_NONE"
                    ),
                    types.SafetySetting(
                        category="HARM_CATEGORY_HATE_SPEECH", threshold="BLOCK_NONE"
                    ),
                    types.SafetySetting(
                        category="HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        threshold="BLOCK_NONE",
                    ),
                    types.SafetySetting(
                        category="HARM_CATEGORY_DANGEROUS_CONTENT",
                        threshold="BLOCK_NONE",
                    ),
                ],
                response_mime_type="application/json",
            )

            # Generate content with retry logic
            try:
                logger.info("Calling Gemini API for content generation...")
                response_text = generate_content_with_retry_extraction(
                    client=client,
                    model=settings.gemini_model_name,
                    contents=contents,
                    config=generate_content_config,
                )
                logger.info(f"Gemini API call completed. Response length: {len(response_text) if response_text else 0}")
            except Exception as e:
                logger.error(f"Content generation failed after retries: {e}")
                logger.error(f"Error type: {type(e).__name__}")
                return None

        except Exception as e:
            logger.error(f"Error in GEMINI Operation: {e}")
            logger.error(f"Error type: {type(e).__name__}")
            return None

        if not response_text or not response_text.strip():
            logger.error("Error: Gemini API returned empty response")
            logger.error("This could be due to:")
            logger.error("1. PDF content is not readable or corrupted")
            logger.error("2. PDF is too large or complex for processing")
            logger.error("3. Gemini API safety filters blocked the content")
            logger.error("4. Network or API service issues")
            return None

        logger.debug(
            f"Gemini API response received (length: {len(response_text)} chars)"
        )

        # Parse the JSON response
        try:
            data = json.loads(response_text)
            doc_type = data.get("document_type", "Unknown")
            doc_id = (
                data.get("invoice_id") or data.get("grn_number") or data.get("po_number")
            )
            logger.info(f"Successfully extracted data for {doc_type}: {doc_id}")
            return data
        except json.JSONDecodeError as e:
            logger.error(f"Error parsing JSON response from Gemini: {e}")
            logger.error(f"Raw response (first 500 chars): {response_text[:500]}...")
            
            # Try to extract any JSON-like content from the response
            import re
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                try:
                    logger.info("Attempting to parse extracted JSON from response...")
                    data = json.loads(json_match.group())
                    logger.info("Successfully parsed extracted JSON")
                    return data
                except json.JSONDecodeError:
                    logger.error("Failed to parse extracted JSON as well")
            
            return None

    except json.JSONDecodeError as e:
        logger.error(f"Error parsing JSON response from Gemini: {e}")
        logger.debug(f"Invalid JSON response preview: {response_text[:200]}...")
        return None
    except Exception as e:
        logger.error(f"Error processing PDF with Gemini: {e}")
        import traceback

        logger.debug(f"Full traceback: {traceback.format_exc()}")
        return None
